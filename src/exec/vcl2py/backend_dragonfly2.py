import re
from vcl2py.ast import *
from vcl2py.log import *

def output(out_file, grammar, params):
    global Grammar, VocolaVersion
    Grammar = grammar
    VocolaVersion = params["Vocola_version"]

    global OUT
    try:
        OUT = open(out_file, "w")
    except IOError, e:
        log_error("Unable to open output file '" + out_file + \
                  "' for writing: " + str(e))
        return

    emit_file_header()

    global Emitted_Rules
    Emitted_Rules = set()

    # don't do title-specific contexts yet:
    if () in grammar["CONTEXTS"].keys():
        rule_names = grammar["CONTEXTS"][()]
        for rule_name in rule_names:
            emit_rule(rule_name, grammar["RULES"][rule_name]) 

    emit_file_trailer()
    OUT.close()

def implementation_error(error):
    log_error(error)
    raise RuntimeError, error    # <<<>>>


# ---------------------------------------------------------------------------
# Emit dragonfly output

def emit_rule(rule_name, rule):
    global Emitted_Rules
    if rule_name in Emitted_Rules:
        return
    Emitted_Rules.add(rule_name)
    # the next line emits as a side effect any rules we are dependent on:
    element_code = code_for_element(rule)
    emit(0, "rule_" + rule_name + " = VocolaRule(\"" + rule_name + "\", " + element_code + ")\n")
    if re.match(r'^[0-9]*$', rule_name):
        emit(0, "grammar.add_rule(rule_" + rule_name + ")\n")

def code_for_element(element):
    type = element["TYPE"]
    if type == "empty":
        return "Empty()"
    elif type == "terminal":
        return "Term(\"" + make_safe_python_string(element["TEXT"]) + "\")"
    elif type == "dictation":
        return "Dictation()"
    elif type == "rule_reference":
        referenced = element["NAME"]
        emit_rule(referenced, Grammar["RULES"][referenced])
        return "RuleRef(rule_" + referenced + ")"
    elif type == "alternatives":
        elements = ", ".join([code_for_element(e) for e in element["CHOICES"]])
        return "Alt([" + elements + "])"
    elif type == "sequence":
        elements = ", ".join([code_for_element(e) for e in element["ELEMENTS"]])
        return "Seq([" + elements + "])"
    elif type == "slot":
        element_code = code_for_element(element["ELEMENT"])
        return "Slot(" + element_code + "," + str(element["NUMBER"]) + ")"
    elif type == "with":
        element_code = code_for_element(element["ELEMENT"])
        actions_code = code_for_actions(element["ACTIONS"])
        return "With(" + element_code + ",\n    " + actions_code + ")"
    else:
        implementation_error("code_for_element: unknown element type: " + type)

def code_for_actions(actions):
    return "["+ ", ".join([code_for_action(action) for action in actions]) + "]"

def code_for_action(action):
    type = action["TYPE"]
    if type == "text":
        text = action["TEXT"]
        return '"' + make_safe_python_string(text) + '"'
    elif type == "reference":
        return "VocolaRef(" + str(action["SLOT"]) + ")"
    elif type == "call":
        return code_for_call(action)
    else:
        implementation_error("Unknown action type: '" + type + "'")

def code_for_call(call):
    call_type = call["CALLTYPE"]
    return call_type_name(call_type) + '(' + \
        '"' + make_safe_python_string(call["NAME"]) + '",' + \
        '[' + ",".join([code_for_actions(a) for a in call["ARGUMENTS"]]) + "])"

def call_type_name(call_type):
    if call_type == "dragon":
        return "DragonCall"
    elif call_type == "vocola":
        return "VocolaCall"
    elif call_type == "extension":
        return "ExtensionCall"
    else:
        implementation_error("Unknown call type: '" + call_type + "'")

# ---------------------------------------------------------------------------
# Utilities used by "emit" methods

def emit(indent, text):
    global OUT
    OUT.write(' ' * (4 * indent) + text)

def make_safe_python_string(text):
    text = text.replace("\\", "\\\\")
    text = text.replace("'", "\\'")
    text = text.replace("\"", "\\\"")
    text = text.replace("\n", "\\n")
    return text


# ---------------------------------------------------------------------------
# Pieces of the output Python file

def emit_file_header():
    global VocolaVersion, OUT
    from time import localtime, strftime

    now = strftime("%a %b %d %H:%M:%S %Y", localtime())
    print >>OUT, "# NatLink macro definitions for dragonfly" 
    print >>OUT, "# coding: latin-1"
    print >>OUT, "# Generated by vcl2py " + VocolaVersion + ", " + now
    print >>OUT, '''
from __future__ import print_function

import dragonfly

# <<<>>>
import sys
try:
    del sys.modules["vocola_dragonfly_runtime"]
except:
    pass

from vocola_dragonfly_runtime import *


#
# Our grammar's rules:
#

context = dragonfly.AppContext(executable="emacs", title="yellow emacs")
grammar = dragonfly.Grammar("Test grammar", context=context)


''',

def emit_file_trailer():
    print >>OUT, '''

print("***** loading...")
grammar.load()
def unload():
    global grammar
    print("***** unloading...")
    if grammar: grammar.unload()
    grammar = None
''',
