import re
from vcl2py.ast import *
from vcl2py.log import *

def output(out_file, grammar, params):
    global Grammar, VocolaVersion
    Grammar = grammar
    VocolaVersion = params["Vocola_version"]

    global OUT
    try:
        OUT = open(out_file, "w")
    except IOError, e:
        log_error("Unable to open output file '" + out_file + \
                  "' for writing: " + str(e))
        return

    emit_file_header()

    global Emitted_Rules
    Emitted_Rules = set()

    # don't do title-specific contexts yet:
    if () in grammar["CONTEXTS"].keys():
        rule_names = grammar["CONTEXTS"][()]
        for rule_name in rule_names:
            emit_rule(rule_name, grammar["RULES"][rule_name]) 

    emit_file_trailer()
    OUT.close()

def implementation_error(error):
    log_error(error)
    raise RuntimeError, error    # <<<>>>


# ---------------------------------------------------------------------------
# Emit dragonfly output

def emit_rule(rule_name, rule):
    global Emitted_Rules
    if rule_name in Emitted_Rules:
        return
    Emitted_Rules.add(rule_name)
    # the next line emits as a side effect any rules we are dependent on:
    element_code = code_for_element(rule)
    emit(0, "rule_" + rule_name + " = VocolaRule(\"" + rule_name + "\", " + element_code + ")\n")
    if re.match(r'^[0-9]*$', rule_name):
        emit(0, "grammar.add_rule(rule_" + rule_name + ")\n")

def code_for_element(element):
    type = element["TYPE"]
    if type == "empty":
        return "VocolaEmpty()"
    elif type == "terminal":
        return "VocolaTerminal(\"" + make_safe_python_string(element["TEXT"]) + "\")"
    elif type == "dictation":
        return "VocolaDictation()"
    elif type == "rule_reference":
        referenced = element["NAME"]
        emit_rule(referenced, Grammar["RULES"][referenced])
        return "VocolaRuleRef(rule_" + referenced + ")"
    elif type == "alternatives":
        elements = ", ".join([code_for_element(e) for e in element["CHOICES"]])
        return "VocolaAlternative([" + elements + "])"
    elif type == "sequence":
        elements = ", ".join([code_for_element(e) for e in element["ELEMENTS"]])
        return "VocolaSequence([" + elements + "])"
    elif type == "slot":
        element_code = code_for_element(element["ELEMENT"])
        return "VocolaSlot(" + element_code + "," + str(element["NUMBER"]) + ")"
    elif type == "act":
        element_code = code_for_element(element["ELEMENT"])
        actions_code = code_for_actions(element["ACTIONS"])
        return "VocolaAct(" + element_code + ",\n    " + actions_code + ")"
    else:
        implementation_error("code_for_element: unknown element type: " + type)

def code_for_actions(actions):
    return "["+ ", ".join([code_for_action(action) for action in actions]) + "]"

def code_for_action(action):
    type = action["TYPE"]
    if type == "text":
        text = action["TEXT"]
        return '"' + make_safe_python_string(text) + '"'
    elif type == "reference":
        return "VocolaRef(" + str(action["SLOT"]) + ")"
    elif type == "call":
        return code_for_call(action)
    else:
        implementation_error("Unknown action type: '" + type + "'")

def code_for_call(call):
    call_type = call["CALLTYPE"]
    return call_type_name(call_type) + '(' + \
        '"' + make_safe_python_string(call["NAME"]) + '",' + \
        '[' + ",".join([code_for_actions(a) for a in call["ARGUMENTS"]]) + "])"

def call_type_name(call_type):
    if call_type == "dragon":
        return "DragonCall"
    elif call_type == "vocola":
        return "VocolaCall"
    elif call_type == "extension":
        return "ExtensionCall"
    else:
        implementation_error("Unknown call type: '" + call_type + "'")

# ---------------------------------------------------------------------------
# Utilities used by "emit" methods

def emit(indent, text):
    global OUT
    OUT.write(' ' * (4 * indent) + text)

def make_safe_python_string(text):
    text = text.replace("\\", "\\\\")
    text = text.replace("'", "\\'")
    text = text.replace("\"", "\\\"")
    text = text.replace("\n", "\\n")
    return text


# ---------------------------------------------------------------------------
# Pieces of the output Python file

def emit_file_header():
    global VocolaVersion, OUT
    from time import localtime, strftime

    now = strftime("%a %b %d %H:%M:%S %Y", localtime())
    print >>OUT, "# NatLink macro definitions for dragonfly" 
    print >>OUT, "# coding: latin-1"
    print >>OUT, "# Generated by vcl2py " + VocolaVersion + ", " + now
    print >>OUT, '''
from __future__ import print_function

import dragonfly
from VocolaUtils import *


#
# Dealing with formatting dictation:
#

def format_words(word_list):
    word_list = [word.encode('Windows-1252') for word in word_list]
    format_words2(word_list)  # for print side effect
    import nsformat
    state = [nsformat.flag_no_space_next]
    result, _new_state = nsformat.formatWords(word_list, state)
    print("format_words: %s -> '%s'"  % (repr(word_list), result))
    return result

def format_words2(word_list):
    result = ""
    for word in word_list:
        # Convert to written form if necessary, e.g. "@\at-sign" --> "@"
        backslashPosition = str.find(word, "\\\\")
        if backslashPosition > 0:
            word = word[:backslashPosition]
        if result != "":
            result = result + " "
        result = result + word
    print("format_words2: %s -> '%s'"  % (repr(word_list), result))
    return result


#
# Elements
#

class VocolaEmpty:
    def to_dragonfly(self):
        #         return Empty(value=self.value)
        #         return Optional(Impossible(), default=self.value)
        return dragonfly.Modifier(dragonfly.Optional(dragonfly.Impossible(), default=None),
                                  lambda value: None)

class VocolaTerminal:
    def __init__(self, terminal_text):
         self.terminal_text = terminal_text

    def to_dragonfly(self):
         return dragonfly.Literal(text=self.terminal_text, value=self.terminal_text)

class VocolaDictation:
    def to_dragonfly(self):
         return dragonfly.Modifier(dragonfly.Dictation(format=False),
                                   lambda words: format_words(words))

class VocolaRuleRef:
    def __init__(self, rule):
         self.rule = rule

    def to_dragonfly(self):
         return dragonfly.RuleRef(rule=self.rule)

class VocolaAlternative:
    def __init__(self, alternatives):
         self.alternatives = alternatives

    def to_dragonfly(self):
         return dragonfly.Alternative(children=[alternative.to_dragonfly() 
                                                for alternative in self.alternatives])

class VocolaSequence:
    def __init__(self, elements):
         self.elements = elements

    def to_dragonfly(self):
         return dragonfly.Sequence(children=[element.to_dragonfly() for element in self.elements])

class VocolaSlot:
    def __init__(self, element, number):
         self.element = element
         self.number = number

    def to_dragonfly(self):
         return dragonfly.Modifier(self.element.to_dragonfly(), 
                                   lambda values: (self.number, reduce_function(values)))

class VocolaAct:
    def __init__(self, element, actions):
         self.element = element
         self.action = VocolaProg(actions)

    def get_bindings(self, value):
        bindings = {}
        if isinstance(value, tuple):
            bindings[value[0]] = value[1]
        if isinstance(value, list):
            for v in value:
                b = self.get_bindings(v)
                bindings.update(b)
        return bindings

    def to_dragonfly(self):
         return dragonfly.Modifier(self.element.to_dragonfly(), 
                                   lambda value: self.action.run(self.get_bindings(value)))


#
# Actions
#

class VocolaProg:
    def __init__(self, actions):
        self.actions = actions

    def run(self, bindings):
        result = ""
        for action in self.actions:
            if isinstance(action, str):
                result += action
            else:
                result += action.run(bindings)
        return result

class VocolaRef:
    def __init__(self, slot):
         self.slot = slot

    def run(self, bindings):
        if self.slot in bindings.keys():
            return bindings[self.slot]
        return ""

# Built in Dragon functions with (minimum number of arguments,
# template of types of all possible arguments); template has one
# letter per argument with s denoting string and i denoting integer:

Dragon_functions = {
                     "ActiveControlPick" : [1,"s"],
                     "ActiveMenuPick"    : [1,"s"],
                     "AppBringUp"        : [1,"ssis"],
                     "AppSwapWith"       : [1,"s"],
                     "Beep"              : [0,""],
                     "ButtonClick"       : [0,"ii"],
                     "ClearDesktop"      : [0,""],
                     "ControlPick"       : [1,"s"],
                     "DdeExecute"        : [3,"sssi"],
                     "DdePoke"           : [4,"ssss"],
                     "DllCall"           : [3,"sss"],
                     "DragToPoint"       : [0,"i"],
                     "GoToSleep"         : [0,""],
                     "HeardWord"         : [1,"ssssssss"],  # max 8 words
                     "HTMLHelp"          : [2,"sss"],
                     "MenuCancel"        : [0,""],
                     "MenuPick"          : [1,"s"],
                     "MouseGrid"         : [0,"ii"],
                     "MsgBoxConfirm"     : [3,"sis"],
                     "PlaySound"         : [1,"s"],
                     "RememberPoint"     : [0,""],
                     "RunScriptFile"     : [1,"s"],
                     "SendKeys"          : [1,"s"],
                     "SendDragonKeys"    : [1,"s"],
                     "SendSystemKeys"    : [1,"si"],
                     "SetMicrophone"     : [0,"i"],
                     "SetMousePosition"  : [2,"iii"],
                     "SetNaturalText"    : [1,"i"],
                     "ShellExecute"      : [1,"siss"],
                     "ShiftKey"          : [0,"ii"],
                     "TTSPlayString"     : [0,"ss"],
                     "Wait"              : [1,"i"],
                     "WaitForWindow"     : [1,"ssi"],
                     "WakeUp"            : [0,""],
                     "WinHelp"           : [2,"sii"],
                    }

class ActionCall:
    def __init__(self, name, arguments):
        self.name = name
        self.arguments = [VocolaProg(actions) for actions in arguments]

class DragonCall(ActionCall):
    def run(self, bindings):
        dragon_info = Dragon_functions[self.name][1]
        values = [argument.run(bindings) for argument in self.arguments]
        call_Dragon(self.name, dragon_info, values)
        return ""

class VocolaCall(ActionCall):
    def run(self, bindings):
        return "called"

class ExtensionCall(ActionCall):
    def run(self, bindings):
        return "called"
    

#
# Rules
#

class VocolaRule(dragonfly.Rule):
    def __init__(self, name_, element_):
        dragonfly.Rule.__init__(self, name=name_, element=element_.to_dragonfly())
        print(repr(element_.to_dragonfly().gstring()))

    def process_recognition(self, node):
        try:
            result_value = node.value()
            print(self.name + " got raw result " + repr(result_value))
            result = reduce_function(result_value)
            print(self.name + " got reduced result `" + result + "`")
        except Exception as e:
            print(self.name + " threw exception: " + repr(e))

def reduce_function(value):
    if value is None:
        return ""
    if isinstance(value, str):
        return value
    if isinstance(value, list):
        reduced = [reduce_function(v) for v in value]
        words = [w for w in reduced if w != ""]
        return " ".join(words)
    return "UNKNOWN"


#
# Our grammar's rules:
#

context = dragonfly.AppContext(executable="emacs", title="yellow emacs")
grammar = dragonfly.Grammar("Test grammar", context=context)


''',

def emit_file_trailer():
    print >>OUT, '''

print("***** loading...")
grammar.load()
def unload():
    global grammar
    print("***** unloading...")
    if grammar: grammar.unload()
    grammar = None
''',
